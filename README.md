# WEGO

A Micro Services Framework 

# Introduction

WEGO is a flexible (yet opinionated) framework that is suitable for rapid development of micro services. The 
GOLANG architect has a few important responsibilities:
1. Make a choice from various frameworks that exist in the GO LANG ecosystem.
2. Standardize them and 

GOLANG has a nice ecosystem of packages that solves specific problems very well. When it comes to writing
Micro services, the developer has the onus of stitching them all together to make them perform the work. This 
presents a few challenges:
1. The author has to decide  

The chief benefit of WEGO is that it comes integrated with different frameworks that have been standardized such as: 
- gorilla MUX (for HTTP)
- Uber zap (for logging)
- New Relic (for monitoring)
- GoDog (for BDD)
- Viper (for configuration management)
- Nick Snyder's go-i18n 

Besides integration with frameworks, BPlus accomplishes the following:
* Provide a standardized folder structure for development.
* Allows developers to focus on business logic without being bothered about how services are exposed via HTTP etc.
* Facilitates interface service separation
* Integrates with Make for builds. See [approach to builds](build.md)
* Integrates with Docker for deployment. See [docker integration](docker.md)
* Exposes HTTP for the services. For details see the [http module](http/README.md)
* Enforces a common set of middlewares. For details see the [discussion on middleware](internal/mw/README.md)
* Facilitates rapid development using a code generator. For details see the 
[discussion on code-gen](https://gitlab.intelligentb.com/devops/code-gen/README.md)
* Implements a state machine. See [the BPlus State Machine](stm/README.md)
* Provides a consistent way of handling Errors. See [Error Handling](err/README.md)
* Provides the following functionalities as horizontal services. (a growing set)
    # Logging. See [BPlus Logging](log/README.md)
    # Auditing (not implemented yet)
    # Monitoring. See [BPlus integration with New Relic](new-relic.md)
    # Configuration Management. See [BPlus approach to Configuration Management](config.md)

# Modularized code base

BPlus is a modularized code base with a base framework and several set of plug-ins. All the plug-ins
are shipped together in one GO Module. However, it is easy to dissociate them if the need so arises.

# Folder Structure
BPlus is best implemented using a folder structure as follows:
$ mkdir src
$ cd src
$ git clone intelligentb.gitlab.com/bplus (get the actual git repo url)
$ git clone intelligentb.gitlab.com/code-gen (get the actual git repo url)
$ mkdir configs

All included git projects within Intelligent B including BPlus will be under src. Reference to other Intelligent B 
projects will be relative. For example, you will create a relative path to BPlus in your module by typing the 
following:
$ cd src/my-service
$ go mod edit --alter intelligentb.gitlab.com/devops/bplus=../bplus

This establishes the relative path to bplus from your service and allows changing of the bplus code without 
requiring "go" to extract the latest code from gitlab.

## Project Types
We would have three sets of projects that need to be developed. All these project templates are generated 
automatically using code-gen. These include the following:
1. A service project. This is the project that a developer uses to develop a micro service.
2. A deploy project. This gives a dev-ops person the flexibility to package multiple micro services into a 
single deploy-able artifact.
3. A state service project. This is a project that uses a state machine for developing services. The 
chief difference between this and the service project is that this project is driven by a state machine.
The code structuring is around the state machine. 

#  Development & Test Process

The Makefile generated by __code-gen__ and which becomes part of every service accomplishes a few things to 
make it easier for the development and testing process. Before we launch into a discussion of these features,
we need to understand the _dependencies.txt_ file which is generated by __code-gen__.

## dependencies.txt file

Every service will have a dependencies.txt file that contains the dependencies for the service. Dependencies 
are Intelligent B projects.(Dont confuse these with external open source dependencies such as go-kit, viper, 
mux etc.) This file is not supposed to replicate what is already contained in files _go.mod_. 
However this file is necessary to accomplish the following objectives:

* To enable developers to make changes in the dependency project  and seeing these changes immediately being 
reflected in their code base without the need for doing a "git commit". This is accomplished by doing a 
"go mod edit --alter dependency-project-url=../dependency-project-relative-path"
This creates an entry in _go.mod_ for the relative path to this folder.
* To copy the resource bundles from the dependent projects into a common area 
* To copy environment settings from the dependent projects into a common area
* To copy workflow resource files to a common area
* To execute the go generate for error codes for the dependent projects.

## Steps 

Development involves the following steps:
1. Building - __make build__
2. Running unit tests - __make test__
3. Editing _go.mod_ to use the relative paths rather than the gitlab URL for dependent projects. This in turn enables developers to
make local changes to dependent 
4. Code Generation (for generating error descriptions)- __make generate-error-codes__ 
5. Copy the configurations (under the configs folder to the CONFIG PATH. The config path is by default located 
at ../configs. __make copy-bundles__
6. Running the executable - __make run__

In reality, the Makefile defines the targets - __generate-error-codes__ and __copy-bundles__ as 
dependencies of the __run__ target. Hence triggering step#6 above automatically triggers step#1, step#3, step#4 and
step#5.


# Deployment Process

The services can be tested in isolation 
